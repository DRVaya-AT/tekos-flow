{"version":3,"sources":["../../src/models/relations.js"],"names":["Relations","relationType","eventType","room","_onEventStatus","event","status","isSending","removeListener","EventStatus","CANCELLED","_removeEvent","_onBeforeRedaction","redactedEvent","_relations","has","delete","_removeAnnotationFromAggregation","_targetEvent","makeReplaced","getLastReplacement","setTimeout","emit","_annotationsByKey","_annotationsBySender","_sortedAnnotationsByKey","relation","getRelation","console","error","rel_type","getType","on","add","_addAnnotationToAggregation","key","eventsForKey","push","sort","a","b","aEvents","bEvents","size","sender","getSender","eventsFromSender","getRelations","reduce","last","getTs","replacement","EventEmitter"],"mappings":"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","file":"relations.js","sourcesContent":["/*\nCopyright 2019 New Vector Ltd\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport EventEmitter from 'events';\nimport { EventStatus } from '../../lib/models/event';\n\n/**\n * A container for relation events that supports easy access to common ways of\n * aggregating such events. Each instance holds events that of a single relation\n * type and event type. All of the events also relate to the same original event.\n *\n * The typical way to get one of these containers is via\n * EventTimelineSet#getRelationsForEvent.\n */\nexport default class Relations extends EventEmitter {\n    /**\n     * @param {String} relationType\n     * The type of relation involved, such as \"m.annotation\", \"m.reference\",\n     * \"m.replace\", etc.\n     * @param {String} eventType\n     * The relation event's type, such as \"m.reaction\", etc.\n     * @param {?Room} room\n     * Room for this container. May be null for non-room cases, such as the\n     * notification timeline.\n     */\n    constructor(relationType, eventType, room) {\n        super();\n        this.relationType = relationType;\n        this.eventType = eventType;\n        this._relations = new Set();\n        this._annotationsByKey = {};\n        this._annotationsBySender = {};\n        this._sortedAnnotationsByKey = [];\n        this._targetEvent = null;\n    }\n\n    /**\n     * Add relation events to this collection.\n     *\n     * @param {MatrixEvent} event\n     * The new relation event to be added.\n     */\n    addEvent(event) {\n        if (this._relations.has(event)) {\n            return;\n        }\n\n        const relation = event.getRelation();\n        if (!relation) {\n            console.error(\"Event must have relation info\");\n            return;\n        }\n\n        const relationType = relation.rel_type;\n        const eventType = event.getType();\n\n        if (this.relationType !== relationType || this.eventType !== eventType) {\n            console.error(\"Event relation info doesn't match this container\");\n            return;\n        }\n\n        // If the event is in the process of being sent, listen for cancellation\n        // so we can remove the event from the collection.\n        if (event.isSending()) {\n            event.on(\"Event.status\", this._onEventStatus);\n        }\n\n        this._relations.add(event);\n\n        if (this.relationType === \"m.annotation\") {\n            this._addAnnotationToAggregation(event);\n        } else if (this.relationType === \"m.replace\" && this._targetEvent) {\n            this._targetEvent.makeReplaced(this.getLastReplacement());\n        }\n\n        event.on(\"Event.beforeRedaction\", this._onBeforeRedaction);\n\n        this.emit(\"Relations.add\", event);\n    }\n\n    /**\n     * Remove relation event from this collection.\n     *\n     * @param {MatrixEvent} event\n     * The relation event to remove.\n     */\n    _removeEvent(event) {\n        if (!this._relations.has(event)) {\n            return;\n        }\n\n        const relation = event.getRelation();\n        if (!relation) {\n            console.error(\"Event must have relation info\");\n            return;\n        }\n\n        const relationType = relation.rel_type;\n        const eventType = event.getType();\n\n        if (this.relationType !== relationType || this.eventType !== eventType) {\n            console.error(\"Event relation info doesn't match this container\");\n            return;\n        }\n\n        this._relations.delete(event);\n\n        if (this.relationType === \"m.annotation\") {\n            this._removeAnnotationFromAggregation(event);\n        } else if (this.relationType === \"m.replace\" && this._targetEvent) {\n            this._targetEvent.makeReplaced(this.getLastReplacement());\n        }\n\n        this.emit(\"Relations.remove\", event);\n    }\n\n    /**\n     * Listens for event status changes to remove cancelled events.\n     *\n     * @param {MatrixEvent} event The event whose status has changed\n     * @param {EventStatus} status The new status\n     */\n    _onEventStatus = (event, status) => {\n        if (!event.isSending()) {\n            // Sending is done, so we don't need to listen anymore\n            event.removeListener(\"Event.status\", this._onEventStatus);\n            return;\n        }\n        if (status !== EventStatus.CANCELLED) {\n            return;\n        }\n        // Event was cancelled, remove from the collection\n        event.removeListener(\"Event.status\", this._onEventStatus);\n        this._removeEvent(event);\n    }\n\n    /**\n     * Get all relation events in this collection.\n     *\n     * These are currently in the order of insertion to this collection, which\n     * won't match timeline order in the case of scrollback.\n     * TODO: Tweak `addEvent` to insert correctly for scrollback.\n     *\n     * @return {Array}\n     * Relation events in insertion order.\n     */\n    getRelations() {\n        return [...this._relations];\n    }\n\n    _addAnnotationToAggregation(event) {\n        const { key } = event.getRelation();\n        if (!key) {\n            return;\n        }\n\n        let eventsForKey = this._annotationsByKey[key];\n        if (!eventsForKey) {\n            eventsForKey = this._annotationsByKey[key] = new Set();\n            this._sortedAnnotationsByKey.push([key, eventsForKey]);\n        }\n        // Add the new event to the set for this key\n        eventsForKey.add(event);\n        // Re-sort the [key, events] pairs in descending order of event count\n        this._sortedAnnotationsByKey.sort((a, b) => {\n            const aEvents = a[1];\n            const bEvents = b[1];\n            return bEvents.size - aEvents.size;\n        });\n\n        const sender = event.getSender();\n        let eventsFromSender = this._annotationsBySender[sender];\n        if (!eventsFromSender) {\n            eventsFromSender = this._annotationsBySender[sender] = new Set();\n        }\n        // Add the new event to the set for this sender\n        eventsFromSender.add(event);\n    }\n\n    _removeAnnotationFromAggregation(event) {\n        const { key } = event.getRelation();\n        if (!key) {\n            return;\n        }\n\n        const eventsForKey = this._annotationsByKey[key];\n        if (eventsForKey) {\n            eventsForKey.delete(event);\n\n            // Re-sort the [key, events] pairs in descending order of event count\n            this._sortedAnnotationsByKey.sort((a, b) => {\n                const aEvents = a[1];\n                const bEvents = b[1];\n                return bEvents.size - aEvents.size;\n            });\n        }\n\n        const sender = event.getSender();\n        const eventsFromSender = this._annotationsBySender[sender];\n        if (eventsFromSender) {\n            eventsFromSender.delete(event);\n        }\n    }\n\n    /**\n     * For relations that have been redacted, we want to remove them from\n     * aggregation data sets and emit an update event.\n     *\n     * To do so, we listen for `Event.beforeRedaction`, which happens:\n     *   - after the server accepted the redaction and remote echoed back to us\n     *   - before the original event has been marked redacted in the client\n     *\n     * @param {MatrixEvent} redactedEvent\n     * The original relation event that is about to be redacted.\n     */\n    _onBeforeRedaction = (redactedEvent) => {\n        if (!this._relations.has(redactedEvent)) {\n            return;\n        }\n\n        this._relations.delete(redactedEvent);\n\n        if (this.relationType === \"m.annotation\") {\n            // Remove the redacted annotation from aggregation by key\n            this._removeAnnotationFromAggregation(redactedEvent);\n        } else if (this.relationType === \"m.replace\" && this._targetEvent) {\n            this._targetEvent.makeReplaced(this.getLastReplacement());\n        }\n\n        redactedEvent.removeListener(\"Event.beforeRedaction\", this._onBeforeRedaction);\n\n        // Dispatch a redaction event on this collection. `setTimeout` is used\n        // to wait until the next event loop iteration by which time the event\n        // has actually been marked as redacted.\n        setTimeout(() => {\n            this.emit(\"Relations.redaction\");\n        }, 0);\n    }\n\n    /**\n     * Get all events in this collection grouped by key and sorted by descending\n     * event count in each group.\n     *\n     * This is currently only supported for the annotation relation type.\n     *\n     * @return {Array}\n     * An array of [key, events] pairs sorted by descending event count.\n     * The events are stored in a Set (which preserves insertion order).\n     */\n    getSortedAnnotationsByKey() {\n        if (this.relationType !== \"m.annotation\") {\n            // Other relation types are not grouped currently.\n            return null;\n        }\n\n        return this._sortedAnnotationsByKey;\n    }\n\n    /**\n     * Get all events in this collection grouped by sender.\n     *\n     * This is currently only supported for the annotation relation type.\n     *\n     * @return {Object}\n     * An object with each relation sender as a key and the matching Set of\n     * events for that sender as a value.\n     */\n    getAnnotationsBySender() {\n        if (this.relationType !== \"m.annotation\") {\n            // Other relation types are not grouped currently.\n            return null;\n        }\n\n        return this._annotationsBySender;\n    }\n\n    /**\n     * Returns the most recent (and allowed) m.replace relation, if any.\n     *\n     * This is currently only supported for the m.replace relation type,\n     * once the target event is known, see `addEvent`.\n     *\n     * @return {MatrixEvent?}\n     */\n    getLastReplacement() {\n        if (this.relationType !== \"m.replace\") {\n            // Aggregating on last only makes sense for this relation type\n            return null;\n        }\n        if (!this._targetEvent) {\n            // Don't know which replacements to accept yet.\n            // This method shouldn't be called before the original\n            // event is known anyway.\n            return null;\n        }\n        return this.getRelations().reduce((last, event) => {\n            if (event.getSender() !== this._targetEvent.getSender()) {\n                return last;\n            }\n            if (last && last.getTs() > event.getTs()) {\n                return last;\n            }\n            return event;\n        }, null);\n    }\n\n    /*\n     * @param {MatrixEvent} targetEvent the event the relations are related to.\n     */\n    setTargetEvent(event) {\n        if (this._targetEvent) {\n            return;\n        }\n        this._targetEvent = event;\n        if (this.relationType === \"m.replace\") {\n            const replacement = this.getLastReplacement();\n            // this is the initial update, so only call it if we already have something\n            // to not emit Event.replaced needlessly\n            if (replacement) {\n                this._targetEvent.makeReplaced(replacement);\n            }\n        }\n    }\n}\n"]}